
package trig
{
    type BAM16:  _ufix(16,16);	// binary angular measure
    const TwoPi: BAM16 = 1.0;
    type Q16_14: _sfix(16,14): rndns;

    const tabatan: [16] Q16_14 =
    {	0.50000000000000,
	0.29516723530087,
	0.15595826075474,
	0.07916684832113,
	0.03973704861108,
	0.01988789564718,
	0.00994637455790,
	0.00497349078734,
	0.00248678333743,
	0.00124339641185,
	0.00062169879882,
	0.00031084947352,
	0.00015542474603,
	0.00007771237417,
	0.00003885618723,
    };

    const kfactor: Q16_14 = 0.60725293500888;

    /*
     * Sin/Cos via CORDIC method
     * The angle must be in the first quadrant, i.e., 0.0 <= theta < 0.25
     * Therefore the 2 high bits of theta are zero and there are only
     * 14 bits of significance.
     * Result is good to about 14 bits.
     */
    proc cordic(angle: BAM16): Q16_14, Q16_14
    {   var x, y: Q16_14;
	var i: _uint;
	var theta: Q16_14;

	theta = Q16_14(angle);
//err.str("theta="); err.hex16(_uint16(theta)); err.nl();
	x = 0;
	y = kfactor;
	for i from 0 to 14 do
	{
	    if theta <= 0 then
	    {	x, y = x - (y>>i), y + (x>>i);
		theta += tabatan[i];
	    }
	    else
	    {   x, y = x + (y>>i), y - (x>>i);
		theta -= tabatan[i];
	    }
//err.str("tab="); err.hex16(_uint16(tabatan[i]));
//err.str(" theta="); err.hex16(_uint16(theta));
//err.str(" x="); err.hex16(_uint16(x));
//err.str(" y="); err.hex16(_uint16(y));
//err.nl();
	}
//	y = _max(y, 0.0);	// map negative to zero
	if y < 0.0 then y = -y;
	return x, y;
    }

    proc sincos(angle: BAM16): Q16_14, Q16_14
    {   var sin, cos: Q16_14;
	const bam90:  BAM16 = 0.25;
	const bam180: BAM16 = 0.50;
	const bam270: BAM16 = 0.75;

	if angle >= bam90 then
	{   if angle >= bam180 then
	    {   if angle >= bam270 then
		{   sin, cos = cordic(angle-bam270);
		    return -cos, sin;
		}
		else
		{   sin, cos = cordic(angle-bam180);
		    return -sin, -cos;
		}
	    }
	    else
	    {   sin, cos = cordic(angle-bam90);
		return cos, -sin;
	    }
	}
	else
	{   sin, cos = cordic(angle);
	    return sin, cos;
	}
	return sin, cos;
    }

    proc sin(angle: BAM16): Q16_14
    {   var sin, cos: Q16_14;
	sin, cos = sincos(angle);
	return sin;
    }

    proc cos(angle: BAM16): Q16_14
    {   var sin, cos: Q16_14;
	sin, cos = sincos(angle);
	return cos;
    }

    proc cordic2(y: Q16_14, x: Q16_14): BAM16
    {	var theta: Q16_14;
	var i: _uint;

	theta = 0.0;
	for i from 1 to 13 do
	{
	    if y < 0 then
	    {	x, y = x - (y>>i), y + (x>>i);
	        theta -= tabatan[i];
	    }
	    else
	    {   x, y = x + (y>>i), y - (x>>i);
		theta += tabatan[i];
	    }
	}
	return BAM16(theta);
    }

    /*
     * Normalize y, x into the first octant counter-clockwise above the x>0 axis.
     * After normalization, x >= y so y/x <= 1.0
     * Return the mapped y, x and the angle needed for adjustment.
     */
    proc normalize(y: Q16_14, x: Q16_14): Q16_14, Q16_14, BAM16 //: inline
    {   var phi: BAM16;

	phi = 0.0;
	if y < 0  then { x,y = -x,   -y;   phi += 0.500; }
	if x <= 0 then { x,y =  y,   -x;   phi += 0.250; }
	if x <= y then { x,y =  x-y, y-x;  phi += 0.125; }
	return y, x, phi;
    }

    proc atan2(y: Q16_14, x: Q16_14): BAM16
    {   var phi: BAM16;
	var theta: BAM16;

    if y == 0.0 then { if x >= 0 then return 0.00; else return 0.50; }
    if x == 0.0 then { if y >= 0 then return 0.25; else return 0.75; }
//PQ14("Before: y=", y);
//PQ14(" x=", x);
//err.nl();
	// reduce to 1st octant
	y, x, phi = normalize(y, x);
//PQ14("After: y=", y);
//PQ14(" x=", x);
//err.nl();

        return phi + cordic2(y, x);
    }
}

