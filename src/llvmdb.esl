/*
 * Output the debug information as LLVM metadata.
 * The LLVM documentation is incomplete, out-of-date, or just wrong.
 * Use clang's calls to DIBuilder routines (llvm/lib/Analysis/DIBuilder.cpp)
 * in clang/lib/CodeGen/CGDebuginfo.cpp as a reference.
 *
 * Copyright (c) 2010-2015, Brian G. Lucas.  See LICENSE file.
 * $Id$
 */

package llvmdb
{
    alias llvm.f as f;
    type DW_TAG:
    (
	Array=1,
	Class=2,
	EntryPoint=3,
	Enumeration=4,
	FormalParameter=5,
	Label=10,
	Block=11,
	Member=13,
	Pointer=15,
	Reference=16,
	CompileUnit=17,
	String=18,
	Structure=19,
	SubroutineType=21,
	Typedef=22,
	Union=23,
	Inheritance=28,
	Inlined=29,
	Subrange=33,
	BasicType=36,
	Const=38,
	Enumerator=40,
	File=41,
	Subprogram=46,
	GlobalVariable=52,
	Volatile=53,
	Restrict=55,
	Namespace=57,
	AutoVariable=256,
	ArgVariable=257,
	Expression=258,
	Vector=259
    );
    type DW_ATE:
    (	Address=1, Boolean=2, ComplexFloat=3, Float=4, 
	Signed=5, SignedChar=6, Unsigned=7, UnsignedChar=8
    );
    const DWLanguage:_uint32 = 12;	// FIXME: using C99 for now
    const LLVMDebugVersion:_uint32 = 0xC_0000;
    type DIFlags:	// from llvm/include/llvm/Analysis/DebugInfo.h
    ( Private		= 1 << 0,
      Protected		= 1 << 1,
      FwdDecl		= 1 << 2,
      AppleBlock	= 1 << 3,
      BlockByrefStruct	= 1 << 4,
      Virtual		= 1 << 5,
      Artificial	= 1 << 6,
      Explicit		= 1 << 7,
      Prototyped	= 1 << 8,
      ObjcClassComplete	= 1 << 9
    );
    const meta:_byte = '!';		// metadata introducer
    type TermT: (COMMA, BRACE, PAREN, NONE);
    type seqnoT: _uint16;		// meta sequence number
    type LineT:
    {   next:   @LineT;
	tag:    seqnoT;
	lineno: _uint16;
	context:seqnoT;
    };
    type Line: @LineT;
    var seqno: seqnoT;
    var unit, file, subr, blok, expr: seqnoT;
    var nullmeta, filenamedir, globals, subprogs, retained, enums, imported: seqnoT;
    var gvhead, gvtail: Symb;	// linked list of global variables
    var lvhead, lvtail: Symb;	// linked list of local variables
    var sphead, sptail: Symb;	// linked list of subprograms
    var lnhead, lntail: Line;	// linked list of line number descriptors
    var lexblkno: _uint;	// unique id for lexical block
    var curfile: Symb;		// current file

    proc GetLineContext(): seqnoT
    {
	return subr;
    }

    proc PTerminator(term: TermT)
    {
	if term
	is BRACE then f.str("}\n");
	is COMMA then f.str(", ");
	is PAREN then f.str(" )");
    }

    proc PSeq(n: seqnoT)
    {
	f.chr(meta);
	f.uint(n);
    }
    proc PMetaSeq(n: seqnoT)
    {
	PSeq(n);
	if feature.debug > 1 then
	    f.str(" = !{");
	else
	    f.str(" = metadata !{");
    }

    proc PMetaRef(n: seqnoT, term: TermT)
    {
	if feature.debug > 1 then
	    f.str("!");
	else
	    f.str("metadata !");
	f.uint(n);
	PTerminator(term);
    }

    proc PNull(term: TermT)
    {
	f.str("null");
	PTerminator(term);
    }

    proc PBoolean(b: boolean, term: TermT)
    {
	f.str("i1 ");
	if b then f.str("true"); else f.str("false");
	PTerminator(term);
    }

    proc P32(v: _uint32, term: TermT)
    {
	f.str("i32 ");
	f.uint32(v);
	PTerminator(term);
    }

    proc P64(v: _uint64, term: TermT)
    {
	f.str("i64 ");
	f.uint64(v);
	PTerminator(term);
    }

    proc PHeader(tag: seqnoT, dwat: DW_TAG)
    {
	PMetaSeq(tag);
	P32(_uint32(dwat) + LLVMDebugVersion, COMMA);
    }

    proc PString(s: @[]_byte, term: TermT)
    {
	if feature.debug > 1 then
	    f.str("!\"");
	else
	    f.str("metadata !\"");
	if s != 0 then f.str(s);
	f.chr('"');
	PTerminator(term);
    }

    proc PString2(s1: @[]_byte, s2: @[]_byte, delim: _byte, term: TermT)
    {
	f.str("metadata !\"");
	if s1 != 0 then
	{   f.str(s1);
	    f.chr(delim);
	}
	if s2 != 0 then f.str(s2);
	f.chr('"');
	PTerminator(term);
    }

    proc PName(s: Symb, term: TermT)
    {
	if s != 0 && !symb.IsAnon(s@.ident) then
	    PString(s@.ident, term);
	else
	    PString(0, term);
    }

    proc PFullName(s: Symb, term: TermT)
    {
	if s != 0 && !symb.IsAnon(s@.ident) then
	{   if s@.package != 0 then
		PString2(s@.package@.ident, s@.ident, '.', term);
	    else
		PString(s@.ident, term);
	}
	else
	    PString(0, term);
    }

    proc PLinkName(s: Symb, term: TermT)
    {
	if s != 0 && !symb.IsAnon(s@.ident) then
	{   if s@.package != 0 then
		PString2(s@.package@.ident, s@.ident, llvm.package_delimiter, term);
	    else
		PString(s@.ident, term);
	}
	else
	    PString(0, term);
    }

    proc PContext(term: TermT)
    {   var tag: seqnoT;

	tag = file;
	PMetaRef(tag, term);
    }

    proc PListStart(): seqnoT
    {   var tag: seqnoT;

	seqno += 1;  tag = seqno;
	PMetaSeq(tag);
	return tag;
    }
    
    proc PEmptyList(): seqnoT
    {   var tag: seqnoT;

	tag = PListStart();
	P32(0, BRACE);
	return tag;
    }

    const DNul = "\\00";

    proc PDBeg(n: seqnoT, tag: DW_TAG, noterm: boolean)
    {   var tmp: _uint;

	tmp = _uint(tag);
	PMetaSeq(n);
	f.str("!\"0x");
	if tmp > 0xFF then f.chr('1');
	f.hex8(_uint8(tmp));
	if !noterm then
	    f.str(DNul);
    }

    proc PDEnd(term: TermT)
    {
	f.chr('"');
	PTerminator(term);
    }
	
    proc PDHex(x: _uint, noterm: boolean)
    {
	f.str("0x");
	if x > 0xFF then f.chr('1');
	f.hex8(_uint8(x));
	if !noterm then
	    f.str(DNul);
    }

    proc PDUint(x: _uint, noterm: boolean)
    {
	f.uint(x);
	if !noterm then
	    f.str(DNul);
    }

    proc PDBoolean(x: boolean, noterm: boolean)
    {
	if x then f.chr('1'); else f.chr('0');
	if !noterm then
	    f.str(DNul);
    }

    proc PDString(s: @[]_byte, noterm: boolean)
    {
	if s != 0 then f.str(s);
	if !noterm then
	    f.str(DNul);
    }

    proc PDString2(s1: @[]_byte, s2: @[]_byte, delim: _byte, noterm: boolean)
    {
	if s1 != 0 then
	{   f.str(s1);
	    f.chr(delim);
	}
	if s2 != 0 then f.str(s2);
	if !noterm then
	    f.str(DNul);
    }

    proc PDName(s: Symb, noterm: boolean)
    {
	if s != 0 && !symb.IsAnon(s@.ident) then
	    PDString(s@.ident, noterm);
	else
	    PDString(0, noterm);
    }

    proc PDFullName(s: Symb, noterm: boolean)
    {
	if s != 0 && !symb.IsAnon(s@.ident) then
	{   if s@.package != 0 then
		PDString2(s@.package@.ident, s@.ident, '.', noterm);
	    else
		PDString(s@.ident, noterm);
	}
	else
	    PDString(0, noterm);
    }

    proc DefType(t: Type): seqnoT;		// forward

    proc DefFormals(ps: Symb): _uint
    {   var fs: Symb;
	var n: _uint;

	n = 0;
	fs = ps@.parmlist;
	while fs != 0 do
	{   n += 1;
	    DefType(fs@.type);
	    fs = fs@.next;
	}
	return n;
    }
	
    proc DefRetvs(ps: Symb): seqnoT
    {   var retvs, tag: seqnoT;
	var tl: type.TypeList;
	var term: TermT;

	tl = ps@.retvlist;
	if tl == 0 then return 0;		// no returned values (void)
	while tl != 0 do
	{   DefType(tl@.type);
	    tl = tl@.next;
	}
	tl = ps@.retvlist;
	if tl@.next == 0 then			// 1 returned value
	    retvs = tl@.type.dbtag;
	else					// >1 returned values
	{   seqno += 1;
	    retvs = seqno;
	    PMetaSeq(retvs);
	    term = COMMA;
	    while tl != 0 do
	    {   tag = tl@.type.dbtag;
		tl = tl@.next;
		if tl == 0 then term = BRACE;
		PMetaRef(tag, term);
	    }
	}
	return retvs;
    }
	
    proc DefBasicType(dwtype: DW_ATE, t: type.Type): seqnoT
    {   var tagt: seqnoT;

	seqno += 1;  tagt = seqno;
	if feature.debug > 1 then
	{   PDBeg(tagt, BasicType, false);		// tag  
	    PDName(t@.name, false);			// name
	    PDUint(0, false);				// line
	    PDUint(t@.width, false);			// size
	    PDUint(t@.align, false);			// align
	    PDUint(0, false);				// offset
	    PDUint(0, false);				// flags
	    PDUint(_uint(dwtype), true);		// encoding
	    PDEnd(COMMA);
	    PNull(COMMA);				// filename
	    PNull(BRACE);				// context
	}
	else
	{   PHeader(tagt, DW_TAG.BasicType);		// tag
	    PNull(COMMA);				// filename
	    PNull(COMMA);				// unused
	    PName(t@.name, COMMA);			// name
	    P32(0, COMMA);				// line
	    P64(_uint64(t@.width), COMMA);		// size
	    P64(_uint64(t@.align), COMMA);		// align
	    P64(0, COMMA);				// offset
	    P32(0, COMMA);				// flags
	    P32(_uint32(dwtype), BRACE);		// encoding
	}
	return tagt;
    }

    // Used only for feature.debug <= 1
    proc PTypeHeader(tag: seqnoT, dwat: DW_TAG, t:Type)
    {
	if feature.debug > 1 then
	{   
lex.ErrorS(COMPILER, "llvmdb PTypeHeader\n");
	}
	else
	{
	    PHeader(tag, dwat);				// tag
	    PNull(COMMA);				// file/dir FIXME?
	    PNull(COMMA);				// unused
	    PString(0, COMMA);
	    if t@.name != 0 then
		P32(t@.name@.lineno, COMMA);		// line
	    else
		P32(0, COMMA);				// line
	    P64(_uint64(t@.width), COMMA);		// size
	    P64(_uint64(t@.align), COMMA);		// align
	    P64(0, COMMA);				// offset
	    P32(0, COMMA);				// flags
	}
    }

    // Used only for feature.debug > 1
    proc PCompositeType(tag: seqnoT, from: seqnoT, members: seqnoT,
			dwat: DW_TAG, t:Type)
    {
	PDBeg(tag, dwat, false);			// tag
	PDName(t@.name, false);				// name
	if t@.name != 0 then
	    PDUint(t@.name@.lineno, false);		// line
	else
	    PDUint(0, false);				// line
	PDUint(t@.width, false);			// size
	PDUint(t@.align, false);			// align
	PDUint(0, false);				// offset
	PDUint(0, false);				// flags
	PDUint(0, true);				// runtime language
	PDEnd(COMMA);
	PMetaRef(filenamedir, COMMA);			// source file/dir
	PContext(COMMA);				// context
	if from == 0 then
	    PNull(COMMA);
	else
	    PMetaRef(from, COMMA);			// derived from
	if members == 0 then
	    PNull(COMMA);
	else
	    PMetaRef(members, COMMA);			// members
	PNull(COMMA);					// vtable stuff
	PNull(COMMA);					// template stuff
	PNull(BRACE);					// unique ID
    }

    // Used only for feature.debug > 1
    proc PDerivedType(tag: seqnoT, from: seqnoT, dwat: DW_TAG, t:Type)
    {
	PDBeg(tag, dwat, false);			// tag
	PDName(t@.name, false);				// name
	if t@.name != 0 then
	    PDUint(t@.name@.lineno, false);		// line
	else
	    PDUint(0, false);				// line
	PDUint(t@.width, false);			// size
	PDUint(t@.align, false);			// align
	PDUint(0, false);				// offset
	PDUint(0, true);				// flags
	PDEnd(COMMA);
	PMetaRef(filenamedir, COMMA);			// source file/dir
	PContext(COMMA);				// context
	PMetaRef(from, BRACE);				// derived from
    }

    proc DefSubRange(t: Type, signed: boolean): seqnoT
    {   // Not sure what to do with subranges since C,C++ don't have then
	// For now just define them as a basic type

	if signed then
	    return DefBasicType(DW_ATE.Signed, t);
	else
	    return DefBasicType(DW_ATE.Unsigned, t);
    }   


    proc DefSubroutine(stag: seqnoT, ps: Symb);	// forward

    proc DefRefType(t: Type): seqnoT
    {   var tagb, tagr: seqnoT;

	if t@.kind == REFPROC then
	{   seqno += 1;  tagb = seqno;
	    DefSubroutine(tagb, t@.list);
	}
	else
	    tagb = DefType(t@.base);
	seqno += 1;  tagr = seqno;
	if feature.debug > 1 then
	    PDerivedType(tagr, tagb, DW_TAG.Pointer, t);
	else
	{   PTypeHeader(tagr, DW_TAG.Pointer, t);
	    PMetaRef(tagb, BRACE);			// derived from
	}
	return tagr;
    }

    proc DefRange(lo: _uint64, hi: _uint64): seqnoT
    {   var tagr: seqnoT;

	seqno += 1;  tagr = seqno;
	// emit Subrange
	if feature.debug > 1 then
	{   PDBeg(tagr, Subrange, false);
	    PDUint(lo, false);
	    PDUint(hi, true);
	    PDEnd(BRACE);
	}
	else
	{   PHeader(tagr, DW_TAG.Subrange);		// tag
	    P64(lo, COMMA);				// lo value
	    P64(hi, BRACE);				// hi value
	}
	return tagr;
    }

    proc DefEnumConst(s: Symb): seqnoT
    {   var tagc: seqnoT;

	seqno += 1;  tagc = seqno;
	if feature.debug > 1 then
	{   PDBeg(tagc, Enumerator, false);
	    PDName(s, false);
	    PDUint(s@.const@.valu, true);
	    PDEnd(BRACE);
	}
	else
	{   PHeader(tagc, DW_TAG.Enumerator);		// tag
	    PName(s, COMMA);				// name
	    P64(s@.const@.valu, BRACE);			// value
	}
	return tagc;
    }

    proc DefEnumerationType(t: Type): seqnoT
    {   var tag, list, tage: seqnoT;
	var s: Symb;
	var term: TermT;

	// first output all the constants
	s = t@.list;
	while s != 0 do
	{   if s@.dbtag == 0 then
		s@.dbtag = DefEnumConst(s);
	    s = s@.next;
	}
	// then the list
	list = PListStart();
	term = COMMA;  
	s = t@.list;
	while s != 0 do
	{   tag = s@.dbtag;
	    s = s@.next;
	    if s == 0 then term = BRACE;
	    PMetaRef(tag, term);
	}
	seqno += 1;  tage = seqno;
	// emit Enumeration
	if feature.debug > 1 then
	    PCompositeType(tage, 0, list, Enumeration, t);
	else
	{   PTypeHeader(tage, DW_TAG.Enumeration, t);
	    PNull(COMMA);				// derived from
	    PMetaRef(list, COMMA);			// enum list
	    P32(0, COMMA);				// runtime languages
	    PNull(BRACE);				// what is this?
	}
	return tage;
    }

    proc DefArrayType(t: Type): seqnoT
    {   var tagb, tagi, taga, tagl: seqnoT;

	tagb = DefType(t@.base);
	tagi = 0;
	if !t@.flex then
	    tagi = DefRange(t@.lo, t@.hi);
	// LLVM wants a list of indices
	tagl = 0;
	if tagi != 0 then
	{   tagl = PListStart();
	    PMetaRef(tagi, BRACE);
	} 
	seqno += 1;  taga = seqno;
	// emit Array
	if feature.debug > 1 then
	    PCompositeType(taga, tagb, tagl, Array, t);
	else
	{   PTypeHeader(taga, DW_TAG.Array, t);
	    PMetaRef(tagb, COMMA);			// derived from
	    if tagi == 0 then
		PNull(COMMA);				// flex
	    else
		PMetaRef(tagl, COMMA);			// index type list
	    P32(0, COMMA);				// runtime languages
	    PNull(COMMA);				// what is this?
	    PNull(COMMA);				// what is this?
	    PNull(BRACE);				// what is this?
	}
	return taga;
    }

    proc DefField(s: Symb, rec: seqnoT): seqnoT
    {   var tagt, tagf: seqnoT;
	var t: Type;

	t = s@.type;
	tagt = DefType(t);
	seqno += 1;  tagf = seqno;
	// emit Member
	if feature.debug > 1 then
	{   // This is similar to PDerivedType but with more non-null info
	    // offset if the field offset
	    PDBeg(tagf, Member, false);			// tag
	    PDName(s, false);				// name
	    PDUint(s@.lineno, false);			// line
	    PDUint(t@.width, false);			// size
	    PDUint(t@.align, false);			// align
	    PDUint(s@.addr, false);			// offset
	    PDUint(0, true);				// flags
	    PDEnd(COMMA);
	    PMetaRef(filenamedir, COMMA);		// source file/dir
	    PMetaRef(rec, COMMA);			// context (record)
	    PMetaRef(tagt, BRACE);			// derived from
	}
	else
	{   PHeader(tagf, DW_TAG.Member);		// tag
	    PMetaRef(file, COMMA);			// context
	    PName(s, COMMA);				// name
	    PMetaRef(file, COMMA);			// file
	    P32(0, COMMA);				// line
	    P64(_uint64(t@.width), COMMA);		// size
	    P64(_uint64(t@.align), COMMA);		// align
	    P64(s@.addr, COMMA);			// offset
	    P32(0, COMMA);				// flags
	    PMetaRef(tagt, BRACE);			// derived from
	}
	return tagf;
    }

    proc DefRecordType(t: Type): seqnoT
    {   var tag, list, rec: seqnoT;
	var s: Symb;
	var term: TermT;

	// must put the record out first in case of recursion
	// (e.g. field in record points to record)
	seqno += 1;  rec = seqno;
	t@.dbtag = rec;
	seqno += 1;  list = seqno;
	// emit Structure
	if feature.debug > 1 then
	    PCompositeType(rec, 0, list, Structure, t);
	else
	{   PTypeHeader(rec, DW_TAG.Structure, t);
	    PNull(COMMA);				// derived from
	    PMetaRef(list, COMMA);			// field list
	    P32(0, COMMA);				// runtime languages
	    PNull(BRACE);				// what is this?
	}
	// then output all the fields and their types
	s = t@.list;
	while s != 0 do
	{   if s@.dbtag == 0 then
		s@.dbtag = DefField(s, rec);
	    s = s@.next;
	}
	// finally the list of fields
	PMetaSeq(list);
	term = COMMA; 
	s = t@.list;
	while s != 0 do
	{   tag = s@.dbtag;
	    s = s@.next;
	    if s == 0 then term = BRACE;
	    PMetaRef(tag, term);
	}
	return rec;
    }

    proc DefType(t: Type): seqnoT
    {   var tag: seqnoT;

	if t == 0 then return 0;
	tag = t@.dbtag;
	if tag == 0 then
	{   if t@.kind
	    is ENUM then
	    {   if t == type.booltype then
		    tag = DefBasicType(DW_ATE.Boolean, t);
		else
		    tag = DefEnumerationType(t);
	    }
	    is UINT then
	    {   if t == type.bytetype then
		    tag = DefBasicType(DW_ATE.UnsignedChar, t);
		else if t == type.wordtype ||
			t == type.uinttypes[0] ||
			t == type.uinttypes[1] ||
			t == type.uinttypes[2] ||
			t == type.uinttypes[3] then
			    tag = DefBasicType(DW_ATE.Unsigned, t);
		else
		    tag = DefSubRange(t, false);
	    }
	    is SINT then
	    {   if t == type.swordtype ||
		   t == type.inttypes[0] ||
		   t == type.inttypes[1] ||
		   t == type.inttypes[2] ||
		   t == type.inttypes[3] then
			tag = DefBasicType(DW_ATE.Signed, t);
		else
		    tag = DefSubRange(t, true);
	    }
	    is FLOAT then
		tag = DefBasicType(DW_ATE.Float, t);
	    is REF, REFPROC then tag = DefRefType(t);
	    is ARRAY then tag = DefArrayType(t);	// FIXME - packed
	    is RECORD then tag = DefRecordType(t);      // FIXME - packed
	    t@.dbtag = tag;
	}
	return tag;
    }

    proc DefLines()
    {   var ln: Line;

	ln = lnhead;
	while ln != 0 do
	{   if feature.debug > 1 then
	    {   PSeq(ln@.tag);
		f.str(" = !MDLocation(line: ");
		f.uint(ln@.lineno);
		f.str(", column: 0, scope: ");
		PSeq(ln@.context);
		f.str(")\n");
	    }
	    else
	    {   PMetaSeq(ln@.tag);
		P32(ln@.lineno, COMMA);			// line
		P32(1, COMMA);				// column?
		PMetaRef(ln@.context, COMMA);
		PNull(BRACE);
	    }
	    ln = ln@.next;
	}
	lnhead = 0;
	lntail = 0;
    }

    proc PLine(lineno: _uint16)
    {   var tag: seqnoT;
	var ln: Line;

	if lntail != 0 && lntail@.lineno == lineno then
	    tag = lntail@.tag;
	else
	{   seqno += 1;
	    tag = seqno;
	    ln = Line(sys.zalloc(LineT?size));
	    ln@.tag = tag;
	    ln@.lineno = lineno;
	    ln@.context = GetLineContext();
	    if lntail == 0 then
		lnhead = ln;
	    else
		lntail@.next = ln;
	    lntail = ln;
	}
	f.str(", !dbg ");
	PSeq(tag);
    }

    proc DefVar(s: Symb): seqnoT
    {   var tag: seqnoT;

	seqno += 1;
	s@.dbtag = seqno;
	if s@.linkage
	is LOCAL, FORMAL then
	{
	    if feature.debug > 1 then
		f.str("\tcall void @llvm.dbg.declare(metadata ");
	    else
		f.str("\tcall void @llvm.dbg.declare(metadata !{");
	    llvm.PType(s@.type);
	    f.str("* ");
	    llvm.PName(s);
	    if feature.debug <= 1 then f.chr('}');
	    f.str(", metadata !");
	    f.uint(seqno);
	    if feature.debug > 1 then
	    {   f.str(", metadata !");
		f.uint(expr);
	    }
	    f.chr(')');
	    PLine(s@.lineno);
	    f.nl();	
	    if s@.linkage != FORMAL then
	    {   s@.next = 0;
		if lvtail == 0 then
		    lvhead = s;
		else
		    lvtail@.next = s;
		lvtail = s;
	    }
	}
	else
	{
	    tag = DefType(s@.type);
	    if feature.debug > 1 then
	    {   PDBeg(s@.dbtag, GlobalVariable, false); // tag
		PDFullName(s, false);			// name
		PDFullName(s, false);			// display name
		PDString(0, false);			// linkage name
		PDUint(s@.lineno, false);		// line
		PDBoolean(s@.linkage == NORMAL, false);	// 0=global 1=static
		PDBoolean(s@.linkage != EXTERN, true);  // is a definition
		PDEnd(COMMA);
		PNull(COMMA);		    // FIXME    // context
		PMetaRef(file, COMMA);			// file
		PMetaRef(tag, COMMA);			// type
		llvm.PType(s@.type);
		f.str("* ");
		llvm.PName(s);
		PTerminator(COMMA);
		PNull(BRACE);
	    }
	    else
	    {
		PHeader(s@.dbtag, DW_TAG.GlobalVariable); // tag
		P32(0, COMMA);				// unused
		PNull(COMMA);				// context
		PFullName(s, COMMA);			// name
		PFullName(s, COMMA);			// display name
		PString(0, COMMA);			// linkage name
		PMetaRef(file, COMMA);			// file
		P32(s@.lineno, COMMA);			// line
		PMetaRef(tag, COMMA);			// type
		P32(_uint32(s@.linkage == NORMAL), COMMA); // is "static"
		P32(_uint32(s@.linkage != EXTERN), COMMA); // is a definition
		llvm.PType(s@.type);
		f.str("* ");
		llvm.PName(s);
		PTerminator(COMMA);
		PNull(BRACE);
	    }
	    // We are re-using the next field in Symb,
	    // we are done using it, right?
	    s@.next = 0;
	    if gvtail == 0 then
	    {   gvhead = s;
		gvtail = s;
	    }
	    else
	    {   gvtail@.next = s;
		gvtail = s;
	    }
	}
	return seqno;
    }

    proc DefSubroutine(stag: seqnoT, ps: Symb)
    {   var tag, list: seqnoT;
	var s: Symb;
	var tl: type.TypeList;
	var term: TermT;

	// FIXME: what about multiple returned values?
	// define all the returned values and formals
	tl = ps@.retvlist;
	while tl != 0 do
	{   DefType(tl@.type);
	    tl = tl@.next;
	}
	s = ps@.parmlist;
	while s != 0 do
	{   DefType(s@.type);
	    s = s@.next;
	}
	// now create the list of returned values and formals
	list = PListStart();
	tl = ps@.retvlist;
	s = ps@.parmlist;
	term = COMMA;
	if tl == 0 then				// no return value
	{   if s == 0 then term = BRACE;
	    PNull(term);
	}
	else
	{   while tl != 0 do
	    {   tag = tl@.type@.dbtag;
		tl = tl@.next;
		if tl == 0 && s == 0 then term = BRACE;
		PMetaRef(tag, term);
	    }
	}
	term = COMMA;
	while s != 0 do
	{   tag = s@.type@.dbtag;
	    s = s@.next;
	    if s == 0 then term = BRACE;
	    PMetaRef(tag, term);
	}
	// emit SubroutineType
	if feature.debug > 1 then
	{   PDBeg(stag, SubroutineType, false);		// tag
	    PDString(0, false);				// what is this?
	    PDUint(0, false);				// line
	    PDUint(0, false);				// size
	    PDUint(0, false);				// align
	    PDUint(0, false);				// offset
	    PDUint(0, false);				// flags
	    PDUint(0, true);				// runtime language
	    PDEnd(COMMA);
	    PNull(COMMA);				// source directory
	    PNull(COMMA);				// context
	    PNull(COMMA);				// type derived from
	    PMetaRef(list, COMMA);			// retv and formals?
	    PNull(COMMA);				// base type vtable
	    PNull(COMMA);				// template parameters
	    PNull(BRACE);				// unique ID
	}
	else
	{   PHeader(stag, DW_TAG.SubroutineType);	// tag
	    P32(0, COMMA);				// was context?
	    PNull(COMMA);				// what is this?
	    PString(0, COMMA);				// clang prints ""
	    P32(0, COMMA);				// line
	    P64(0, COMMA);				// size
	    P64(0, COMMA);				// align
	    P64(0, COMMA);				// offset
	    P32(0, COMMA);				// flags?
	    PNull(COMMA);				// what is this?
	    PMetaRef(list, COMMA);			// retv and formals?
	    P32(0, COMMA);				// runtime language
	    PNull(COMMA);
	    PNull(COMMA);
	    PNull(BRACE);
	}
    }

    proc ProcStart(ps: Symb)
    {
	seqno += 1;  subr = seqno;
    }

    proc ProcFinish(ps: Symb)
    {   var s: Symb;
	var stype, stag, ttag, fvars, empty: seqnoT;
	var argno: _uint;

	seqno += 1;  stype = seqno;
	// emit SubProgram
	if feature.debug > 1 then
	{   PDBeg(subr, Subprogram, false);		// tag
	    PDFullName(ps, false);			// name
	    PDFullName(ps, false);			// display name
	    PDString(0, false);				// linkage name
	    PDUint(ps@.lineno, false);			// line
	    PDBoolean(false, false);	//FIXME		// 0=global 1=static
	    PDBoolean(ps@.linkage != EXTERN, false);	// is a definition
	    PDUint(0, false);				// virtuality
	    PDUint(0, false);				// virtual index
	    PDUint(0, false);				// flags
	    PDBoolean(false, false);			// is optimized
	    PDUint(ps@.lineno+1, true);		// line where scope starts
	    PDEnd(COMMA);
	    PMetaRef(filenamedir, COMMA);		// file
	    PContext(COMMA);				// context
	    PMetaRef(stype, COMMA);			// subroutine type
	    PNull(COMMA);				// base type
	    llvm.PRetvType(ps@.retvlist, false);
	    f.str(" (");
	    s = ps@.parmlist;
	    while s != 0 do
	    {   llvm.PType(s@.type);
		s = s@.next;
		if s != 0 then f.str(", ");
	    }
	    f.str(")* ");
	    llvm.PName(ps);
	    PTerminator(COMMA);				// pointer to function
	    PNull(COMMA);				// template parameters
	    PNull(COMMA);				// function declaration
/*
	    // FIXME function variables null list?
	    seqno += 1;  fvars = seqno;
*/
	    fvars = nullmeta;       // FIXME
	    PMetaRef(fvars, BRACE);			// function variables
	}
	else
	{   PHeader(subr, DW_TAG.Subprogram);		// tag
	    PMetaRef(filenamedir, COMMA);		// file
	    PContext(COMMA);				// context
	    PFullName(ps, COMMA);			// name
	    PFullName(ps, COMMA);			// display name
	    PString(0, COMMA);				// linkage name
	    P32(ps@.lineno, COMMA);			// line
	    PMetaRef(stype, COMMA);			// subroutine type
	    PBoolean(false, COMMA);			// FIXME: local
	    PBoolean(ps@.linkage != EXTERN, COMMA);	// is a definition
	    P32(0, COMMA);				// virtuality
	    P32(0, COMMA);				// virtual index
	    PNull(COMMA);				// base type
	    P32(0, COMMA);				// FIXME: DIFlags
	    PBoolean(false, COMMA);			// FIXME: is optimized
	    llvm.PRetvType(ps@.retvlist, false);
	    f.str(" (");
	    s = ps@.parmlist;
	    while s != 0 do
	    {   llvm.PType(s@.type);
		s = s@.next;
		if s != 0 then f.str(", ");
	    }
	    f.str(")* ");
	    llvm.PName(ps);
	    PTerminator(COMMA);				// pointer to function
	    PNull(COMMA);				// template parameters
	    PNull(COMMA);				// function declaration
/*
	    // FIXME function variables null list?
	    seqno += 1;  fvars = seqno;
*/
	    fvars = nullmeta;       // FIXME
	    PMetaRef(fvars, COMMA);			// function variables
	    P32(ps@.lineno+1, BRACE);			// FIXME: scope line
	}
	ps@.dbtag = subr;	// save tag
	ps@.next = 0;		// and add to subprogram list
	if sptail == 0 then
	    sphead = ps;
	else
	    sptail@.next = ps;
	sptail = ps;

	// define all the formals and returned values
	DefFormals(ps);
	DefRetvs(ps);
	// output the subroutine type descriptor
	DefSubroutine(stype, ps);
	// output formal argument descriptors
	argno = 0;
	s = ps@.parmlist;
	while s != 0 do
	{   argno += 1;
	    ttag = DefType(s@.type);
	    stag = s@.dbtag;
	    if stag == 0 then	// FIXME: shouldn't happen
	    {   seqno += 1;
		stag = seqno;
	    }
	    if feature.debug > 1 then
	    {   PDBeg(stag, ArgVariable, false);	// tag
		PDName(s, false);
		PDUint(s@.lineno|(argno<<24), false);
		PDUint(0, true);
		PDEnd(COMMA);
		PMetaRef(subr, COMMA);		// context
		PMetaRef(file, COMMA);		// file
		PMetaRef(ttag, BRACE);		// type
	    }
	    else
	    {
		PHeader(stag, DW_TAG.ArgVariable);	// tag
		PMetaRef(subr, COMMA);		// context
		PName(s, COMMA);			// name
		PMetaRef(file, COMMA);		// file
		P32(s@.lineno|(argno<<24), COMMA);	// line+argno
		PMetaRef(ttag, COMMA);		// type
		P32(0, COMMA);			// flags?
		P32(0, BRACE);			// what is this?
	    }
	    s = s@.next;
	}
	// output local variable descriptors
	s = lvhead;
	while s != 0 do
	{   ttag = DefType(s@.type);
	    stag = s@.dbtag;
	    if feature.debug > 1 then
	    {   PDBeg(stag, AutoVariable, false);	// tag
		PDName(s, false);
		PDUint(s@.lineno, false);
		PDUint(0, true);
		PDEnd(COMMA);
		PMetaRef(subr, COMMA);		// context
		PMetaRef(file, COMMA);		// file
		PMetaRef(ttag, BRACE);		// type
	    }
	    else
	    {   PHeader(stag, DW_TAG.AutoVariable);	// tag
		PMetaRef(blok, COMMA);			// context
		PName(s, COMMA);			// name
		PMetaRef(file, COMMA);			// file
		P32(s@.lineno, COMMA);			// line
		PMetaRef(ttag, COMMA);			// type
		P32(0, COMMA);				// flags?
		P32(0, BRACE);				// what is this?
	    }
	    s = s@.next;
	}
	// output line number descriptors
	DefLines();
	lvhead = 0;
	lvtail = 0;
	subr = 0;
	blok = 0;
    }

    proc PackageStart(name: @[]_byte)
    {
    }

    proc PackageEnd()
    {
    }

    proc PFileDir(seqno: seqnoT, fs: Symb)
    {   var i: _uint;
	var name: @[]_byte;

	name = fs@.ident;
	// need to split the name into file and directory
	i = zstr.rfind(name, '/', lex.PathMax);
	PMetaSeq(seqno);
	if i == lex.PathMax then	// '/' not found
	{   PString(name, COMMA);	// file
	    PString("", BRACE);		// directory
	}
	else
	{   name[i] = 0;
	    PString(name[i+1:], COMMA);	// file
	    PString(name, BRACE);	// directory
	}
    }

    proc FileStart(fs: Symb)
    {
	if curfile != fs then
	{
	    seqno += 1;  filenamedir = seqno;
	    PFileDir(filenamedir, fs);
	    fs@.dbtag = file;
	    curfile = fs;
	}
	seqno += 1;  file = seqno;
	if feature.debug > 1 then
	{   PDBeg(file, File, true);		// tag
	    PDEnd(COMMA);
	}
	else
	    PHeader(file, DW_TAG.File);		// tag	}   
	PMetaRef(filenamedir, BRACE);
    }

    proc FileFinish(fs: Symb)
    {   var ps: Symb;

	ps = fs@.package;
	if ps != 0 then
	    file = ps@.dbtag;		// tag of containing file
	else
	    file = 0;			// must be final end of file
    }

    proc ProgStart(fs: Symb, opt: boolean)
    {
	unit = 0;
	seqno = 2;	// start after module flags below
	seqno += 1;  filenamedir = seqno;
	seqno += 1;  nullmeta = seqno;
//	seqno += 1;  enums = seqno;
//	seqno += 1;  retained = seqno;
	seqno += 1;  subprogs = seqno;
	seqno += 1;  globals = seqno;
//	seqno += 1;  imported = seqno;
	f.str( "declare void @llvm.dbg.declare(metadata, metadata");
	if feature.debug > 1 then
	    f.str( ", metadata");
	f.str( ") nounwind readnone\n");
	// emit anchor
    	f.str("!llvm.dbg.cu = !{!"); f.uint(unit); f.str("}\n");
	f.str("!llvm.module.flags = !{!1, !2}\n");
	if feature.debug > 1 then
	{   f.str("!1 = !{i32 2, !\"Dwarf Version\", i32 4}\n");
	    f.str("!2 = !{i32 2, !\"Debug Info Version\", ");
	    seqno += 1;  expr = seqno;
	}
	else
	{   f.str("!1 = metadata !{i32 2, metadata !\"Dwarf Version\", i32 4}\n");
	    f.str("!2 = metadata !{i32 2, metadata !\"Debug Info Version\", ");
	}
	P32(feature.debug, BRACE);
	// emit Compile Unit
	if feature.debug > 1 then
	{   PDBeg(unit, CompileUnit, false);	// tag
	    PDUint(12, false);			// language id
	    PDString("ESL Compiler", false);	// producer
	    PDBoolean(false, false);		// is optimized
	    PDString(0, false);			// flags
	    PDUint(0, false);			// runtime version
	    PDString(0, false);			// split debug filename
	    PDUint(1, true);			// 1=full info, 2=line info only
	    PDEnd(COMMA);
	    PMetaRef(filenamedir, COMMA);
	    PMetaRef(nullmeta, COMMA);		// list of enum types
	    PMetaRef(nullmeta, COMMA);		// list of retained types
	    PMetaRef(subprogs, COMMA);		// list of subprograms
	    PMetaRef(globals, COMMA);		// list of global variables
	    PMetaRef(nullmeta, BRACE);		// list of imported modules
	}
	else
	{   PHeader(unit, DW_TAG.CompileUnit);	// tag
	    PMetaRef(filenamedir, COMMA);
	    P32(DWLanguage, COMMA);		// language id
	    PString("ESL compiler", COMMA);	// producer
	    PBoolean(opt, COMMA);		// is optimized
	    PString(0, COMMA);			// flags
	    P32(0, COMMA);			// runtime feature.debug
	    PMetaRef(nullmeta, COMMA);		// list of enum types
	    PMetaRef(nullmeta, COMMA);		// list of retained types
	    PMetaRef(subprogs, COMMA);		// list of subprograms
	    PMetaRef(globals, COMMA);		// list of global variables
	    PMetaRef(nullmeta, COMMA);		// list of imported modules
	    PString(0, COMMA);			// split name?
	    P32(1, BRACE);			// kind??
	}
	// file name and directory
	PFileDir(filenamedir, fs);
	curfile = fs;
	fs@.dbtag = file;
	// null meta
	PMetaSeq(nullmeta);
	PTerminator(BRACE);
	if feature.debug > 1 then
	{   // emit dummy expression
	    PDBeg(expr, Expression, true);
	    PDEnd(BRACE);
	}
    }

    proc ProgFinish()
    {   var s: Symb;
	var tag, empty, list: seqnoT;
	var term: TermT;

	// output an empty list
//	seqno += 1;  empty = seqno;
//	PMetaSeq(empty);
//	f.str("i32 0 }\n");
	// output list of enums (NOT USED YET)
//	PMetaSeq(enums);
//	PMetaRef(empty, BRACE);
	// output list of retained types (NOT USED, WHAT IS THIS?)
//	PMetaSeq(retained);
//	PMetaRef(empty, BRACE);

	// output list of subprograms
	PMetaSeq(subprogs);
	s = sphead;
	if s != 0 then
	{   term = COMMA;
	    while s != 0 do
	    {   tag = s@.dbtag;
		s = s@.next;
		if s == 0 then term = BRACE;
		PMetaRef(tag, term);
	    }
	}
	else
	    PTerminator(BRACE);

	// output list of global variables
	PMetaSeq(globals);
	s = gvhead;
	if s != 0 then
	{   term = COMMA;
	    while s != 0 do
	    {   tag = s@.dbtag;
		s = s@.next;
		if s == 0 then term = BRACE;
		PMetaRef(tag, term);
	    }
	}
	else
	    PTerminator(BRACE);
    }
}
// vim: ts=8 sw=4 noet nowrap

